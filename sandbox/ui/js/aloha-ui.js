require([
	'../../src/aloha',
	'../../src/dom',
	'../../src/arrays',
	'../../src/ranges',
	'../../src/boromir',
	'../../src/boundaries',
	'../../src/formatting',
	'../../src/blocks',
	'../../src/dragdrop',
	'../../src/editables',
	'../../src/keys',
	'../../src/mouse',
	'../../src/paste',
	'../../src/selections',
	'../../src/typing'
], function (
	aloha,
	Dom,
	Arrays,
	Ranges,
	Boromir,
	Boundaries,
	Formatting,
	Blocks,
	DragDrop,
	Editables,
	Keys,
	Mouse,
	Paste,
	Selections,
	Typing
) {
	'use strict';

	var CLASS_PREFIX = 'aloha-action-';

	/**
	 * Executes an action object as generated by parseAction() which looks like
	 * one of the following:
	 *
	 * {
	 *    format : true, // it's an action to format something
	 *    node   : 'b'   // as <b>
	 * }
	 *
	 * or even a compound of operations ...
	 *
	 * {
	 *    format     : true,
	 *    node       : 'b',
	 *    style      : true,
	 *    styleName  : 'background',
	 *    styleValue : 'red'
	 * }
	 *
	 * @private
	 * @param  {!Object.<string,?>} action
	 * @param  {!Array.<Boundary>}  boundaries
	 * @param  {!Editor}            editor
	 * @return {Array.<Boundaries>}
	 */
	function execute(action, boundaries, editor) {
		if (action.format) {
			boundaries = Formatting.format(
				action.format,
				boundaries[0],
				boundaries[1]
			);
		}
		if (action.style) {
			boundaries = Formatting.style(
				action.styleName,
				action.styleValue,
				boundaries[0],
				boundaries[1]
			);
		}
		if (action.classes) {
			boundaries = Formatting.classes(
				action.classNames,
				boundaries[0],
				boundaries[1]
			);
		}
		Boundaries.select(boundaries[0], boundaries[1]);
		aloha.selections.show(editor.selectionContext.caret, boundaries[1]);
		return boundaries;
	}

	/**
	 * TODO not finished. this is a simplified implementation
	 * as not all actions are formatting actions
	 *
	 * Extracts the intended aloha action from a dom element.
	 * Will look through the classes to find an aloha-action-* class, which is
	 * then transformed into an action object that looks like the following:
	 * { format: true, node: 'b' }
	 *
	 * @private
	 * @param  {!Element} element
	 * @return {?Object}
	 */
	function parseAction(element) {
		var action = {};
		var className;
		var classes = Arrays.coerce(element.classList).concat(Arrays.coerce(element.parentNode.classList));

		for (var i = 0; i < classes.length; i++) {
			className = classes[i];
			if (className.indexOf(CLASS_PREFIX) === 0) {
				action.format = className.substr(CLASS_PREFIX.length);
				return action;
			}
		}

		return null;
	}

	/**
	 * Transforms an array of dom nodes into an array of node names
	 * for faster iteration, eg:
	 *
	 * [text, h1, text, p] // array contains DOM nodes
	 *
	 * will return:
	 * 
	 * ['P', '#text', 'H1']
	 *
	 * Duplicate entries will be removed, as displayed in the example
	 * above.
	 *
	 * @private
	 * @param {!Array.<Element>} nodes
	 * @return {Array.<string>}
	 */
	function uniqueNodeNames(nodes) {
		var i = nodes.length;
		var arr = [];
		var added = {};
		while (i--) {
			if (!added[nodes[i].nodeName]) {
				arr.push(nodes[i].nodeName);
				added[nodes[i].nodeName] = true;
			}
		}
		return arr;
	}

	/**
	 * Updates the ui according to current state overrides.
	 *
	 * Sets to active all ui toolbar elements that match the current overrides.
	 *
	 * @private
	 * @param {!Array.<Boundary>} boundries
	 */
	function updateUi(boundaries) {
		var startContainer = Boundaries.container(boundaries[0]);
		var document = startContainer.ownerDocument;
		var formatNodes = uniqueNodeNames(Dom.childAndParentsUntilIncl(startContainer, 
			function (node) {
				return node.parentNode && Dom.isEditingHost(node.parentNode);
			}));

		/**
		 * Finds the root ul of a bootstrap dropdown menu
		 * starting from an entry node within the menu.
		 * Returns true until the node is found. Meant to
		 * be used with Dom.upWhile().
		 *
		 * @private
		 * @param {!Node} node
		 * @return {boolean}
		 */
		function isDropdownUl(node) {
			return [].indexOf.call(node.classList, 'dropdown-menu') === -1;
		}

		[].forEach.call(document.querySelectorAll('.aloha-ui-toolbar .active'), function (node) {
			Dom.removeClass(node, 'active');
		});

		formatNodes.forEach(function (format) {
			// update buttons
			var buttons = document.querySelectorAll('.aloha-ui-toolbar .' + CLASS_PREFIX + format),
				i = buttons.length;
			while (i--) {
				buttons[i].className += ' active';
			}

			// update dropdowns
			var dropdownEntries = document
				.querySelectorAll('.aloha-ui-toolbar .dropdown-menu .' + CLASS_PREFIX + format),
				dropdownRoot;
			i = dropdownEntries.length;
			while (i--) {
				dropdownRoot = Dom.upWhile(dropdownEntries[i], isDropdownUl).parentNode;
				dropdownRoot.querySelector('.dropdown-toggle').firstChild.data = 
					dropdownEntries[i].innerText + ' ';
			}
		});
	}

	/**
	 * Handles UI updates invoked by event
	 *
	 * @param {!AlohaEvent} event
	 * @return {AlohaEvent}
	 */
	function handle(event) {
		if (!event.range || (event.type !== 'keyup' && event.type !== 'click')) {
			return event;
		}
		var target = event.nativeEvent.target || event.nativeEvent.srcElement;
		if (Dom.hasClass(target, 'aloha-ephemera')) {
			return event;
		}
		var boundaries = Boundaries.fromRange(event.range);
		var action = parseAction(target);
		if (action) {
			boundaries = execute(action, boundaries, event.editor);
		}
		updateUi(boundaries);
		event.range = Ranges.fromBoundaries(boundaries[0], boundaries[1]);
		return event;
	}

	aloha.editor.stack = [
		handle,
		Selections.handle,
		Typing.handle,
		Blocks.handle,
		DragDrop.handle,
		Paste.handle,
		Editables.handle,
		Mouse.handle,
		Keys.handle
	];
});
